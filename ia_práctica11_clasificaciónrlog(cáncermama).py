# -*- coding: utf-8 -*-
"""IA_Pr√°ctica11-Clasificaci√≥nRLog(C√°ncerMama).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1l4reGgP2raPDJsgAEJ85f6HMMpjtqhrC

# **Pr√°ctica 11: Clasificaci√≥n (C√°ncer de mama)**

Nombre:

No. Cuenta:

Email:

### **Caso de estudio**

Estudios cl√≠nicos a partir de im√°genes digitalizadas de pacientes con c√°ncer de mama de Wisconsin (WDBC, Wisconsin Diagnostic Breast Cancer).

**Objetivo.** Clasificar registros cl√≠nicos de tumores malignos y benignos de cancer de mama a partir de im√°genes digitalizadas.

**Fuente de datos:**

https://archive.ics.uci.edu/ml/datasets/Breast+Cancer+Wisconsin+(Diagnostic)

#### **1) Importar las bibliotecas necesarias y los datos**
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd               # Para la manipulaci√≥n y an√°lisis de datos
import numpy as np                # Para crear vectores y matrices n dimensionales
import matplotlib.pyplot as plt   # Para la generaci√≥n de gr√°ficas a partir de los datos
import seaborn as sns             # Para la visualizaci√≥n de datos basado en matplotlib
# %matplotlib inline

BCancer = pd.read_csv('Datos/WDBCOriginal.csv')
BCancer

print(BCancer.groupby('Diagnosis').size())

"""#### **2) Selecci√≥n de caracter√≠sticas**

Se utiliza una matriz de correlaciones con el prop√≥sito de seleccionar variables significativas.
"""

sns.pairplot(BCancer, hue='Diagnosis')
plt.show()

#plt.plot(BCancer['Radius'], BCancer['Perimeter'], 'b+')
sns.scatterplot(x='Radius', y ='Perimeter', data=BCancer, hue='Diagnosis')
plt.title('Gr√°fico de dispersi√≥n')
plt.xlabel('Radius')
plt.ylabel('Perimeter')
plt.show()

CorrBCancer = BCancer.corr(method='pearson')
CorrBCancer

plt.figure(figsize=(14,7))
MatrizInf = np.triu(BCancer.corr())
sns.heatmap(BCancer.corr(), cmap='RdBu_r', annot=True, mask=MatrizInf)
plt.show()

"""**Varibles seleccionadas:**

1) Textura [Posici√≥n 3]

2) Area [Posici√≥n 5]

3) Smoothness [Posici√≥n 6]

4) Compactness [Posici√≥n 7]

5) Symmetry [Posici√≥n 10]

6) FractalDimension [Posici√≥n 11]

#### **3) Definici√≥n de variables predictoras y variable clase**
"""

BCancer = BCancer.replace({'M': 0, 'B': 1})
BCancer

print(BCancer.groupby('Diagnosis').size())

#Variables predictoras
X = np.array(BCancer[['Texture', 
                      'Area', 
                      'Smoothness', 
                      'Compactness', 
                      'Symmetry', 
                      'FractalDimension']])
#X = BCancer.iloc[:, [3, 5, 6, 7, 10, 11]].values  #iloc para seleccionar filas y columnas seg√∫n su posici√≥n
pd.DataFrame(X)

#Variable clase
Y = np.array(BCancer[['Diagnosis']])
pd.DataFrame(Y)

plt.figure(figsize=(10, 7))
plt.scatter(X[:,0], X[:,1], c = BCancer.Diagnosis)
plt.grid()
plt.xlabel('Texture')
plt.ylabel('Area')
plt.show()

"""#### **4) Aplicaci√≥n del algoritmo**

Regresi√≥n log√≠stica


"""

#Se importan las bibliotecas necesarias para generar el modelo de regresi√≥n log√≠stica
from sklearn import model_selection
from sklearn import linear_model
from sklearn.metrics import classification_report
from sklearn.metrics import confusion_matrix
from sklearn.metrics import accuracy_score

X_train, X_validation, Y_train, Y_validation = model_selection.train_test_split(X, Y, 
                                                                test_size = 0.2, 
                                                                random_state = 1234,
                                                                shuffle = True)

pd.DataFrame(X_train)

print(len(X_train))
print(len(X_validation))

#Se entrena el modelo a partir de los datos de entrada
ClasificacionRL = linear_model.LogisticRegression()
ClasificacionRL.fit(X_train, Y_train)

"""Se generan las probabilidades"""

#Predicciones probabil√≠sticas de los datos de prueba
Probabilidad = ClasificacionRL.predict_proba(X_validation)
pd.DataFrame(Probabilidad).round(4)

#Clasificaci√≥n final 
Y_ClasificacionRL = ClasificacionRL.predict(X_validation)
print(Y_ClasificacionRL)

#Se calcula la exactitud promedio de la validaci√≥n
accuracy_score(Y_validation, Y_ClasificacionRL)

"""#### **5) Validaci√≥n del modelo**

"""

#Matriz de clasificaci√≥n
ModeloClasificacion = ClasificacionRL.predict(X_validation)
Matriz_Clasificacion = pd.crosstab(Y_validation.ravel(), 
                                   ModeloClasificacion, 
                                   rownames=['Reales'], 
                                   colnames=['Clasificaci√≥n']) 
Matriz_Clasificacion

#Reporte de la clasificaci√≥n
print("Exactitud:", accuracy_score(Y_validation, Y_ClasificacionRL))
print(classification_report(Y_validation, Y_ClasificacionRL))

from sklearn.metrics import RocCurveDisplay
CurvaROC = RocCurveDisplay.from_estimator(ClasificacionRL, X_validation, Y_validation, name="C√°ncer de mama")
plt.show()

"""#### **6) Ecuaci√≥n del modelo de clasificaci√≥n**"""

#Ecuaci√≥n del modelo
print("Intercept:", ClasificacionRL.intercept_)
print('Coeficientes: \n', ClasificacionRL.coef_)

"""
Prob = 1/1+ùëí^‚àí(ùëé+ùëèùëã))

ùëé+ùëèùëã = 12.025 ‚Äì 0.195Texture ‚Äì 0.011Area ‚Äì 0.707Smoothness ‚Äì 2.592Compactness ‚Äì 1.025Symmetry ‚Äì 0.257FractalDimension
"""

#Paciente P-842302 (1) -Tumor Maligno-
PacienteID1 = pd.DataFrame({'Texture': [12.38], 
                            'Area': [1500.0], 
                            'Smoothness': [0.11840], 
                            'Compactness': [0.27760], 
                            'Symmetry': [0.2419], 
                            'FractalDimension': [0.07871]})
ClasificacionRL.predict(PacienteID1)

#Paciente P-92751 (569) -Tumor Benigno-
PacienteID2 = pd.DataFrame({'Texture': [24.54], 
                            'Area': [181.0], 
                            'Smoothness': [0.05263], 
                            'Compactness': [0.04362], 
                            'Symmetry': [0.1587], 
                            'FractalDimension': [0.05884]})
ClasificacionRL.predict(PacienteID2)

